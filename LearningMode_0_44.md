#Using naxsi learning mode (starting from v0.44)


## nx\_intercept.py ##

```

$ python nx_intercept.py /path/to/conf/file

```

The learning daemon itself, even if he does a very limited job.

Basically, it should be pointed by your /RequestDenied location while in learning mode, in order to receive "to-be-blocked" requests.

When doing so, the nx\_intercept.py daemon will store naxsi signatures extracted from the HTTP requests into a MySQL or sqlite database.

It can as well, store the HTTP requests for further analysis if you ask
> him. (see --add-monitoring - still experimental :p)


## nx\_extract.py ##

```

$ python nx_extract.py /path/to/conf/file
```


The daemon you use to obtain whitelists generated by naxsi. Runs by default on port 8081, you will find help here.
You can as well use it to

## Setup ##

nx\_extract and nx\_intercept both relies on a configuration file that is the only parameter :

```

$ cat naxsi-ui-learning.conf
[nx_extract]
username = naxsi_web
password = test
port = 8081
rules_path = /usr/local/nginx/sec-rules/core.rules

[nx_intercept]
port = 8080

[mysql]
username = root
password =
hostname = 127.0.0.1
dbname = naxsi_sig
```

MySQL section is mandatory. In the nx\_extract section, you can setup username and password for http authentication. rules\_path is an optionial path to your core rules file to make whitelist reading easier.

## Example ##

my sites-enabled/foobar :
```

server {
proxy_set_header Proxy-Connection "";
listen       *:80;
access_log  /tmp/nginx_access.log;
error_log  /tmp/nginx_error.log debug;

server_name blog.memze.ro;

location / {
include    /etc/nginx/memzero.rules;
proxy_pass http://88.191.133.106/;
proxy_set_header Host blog.memze.ro;
}

location /RequestDenied {
proxy_pass http://127.0.0.1:8000;
}
}
```


my /etc/nginx/memzero.rules :
```

LearningMode;
SecRulesEnabled;
#SecRulesDisabled;
DeniedUrl "/RequestDenied";

## check rules
CheckRule "$SQL >= 8" BLOCK;
CheckRule "$RFI >= 8" BLOCK;
CheckRule "$TRAVERSAL >= 4" BLOCK;
CheckRule "$EVADE >= 4" BLOCK;
CheckRule "$XSS >= 8" BLOCK;
```

Here, I modified my /etc/hosts to point blog.memze.ro to 127.0.0.1.

While you browse on the website, you will probably generate exceptions.
Those exceptions will be catched by nx\_intercept.py (as it is being pointed by /RequestDenied location), and put into the MySQL database.

You must launch nx\_intercept first, browse a bit (so it creates the database and populates it), and then fire nx\_extract.

By pointing your browser at 127.0.0.1:8081, you will land onto nx\_extract
nx\_extract allows you to get whitelists from generated exceptions.



## Usage ##

Point your browser at 127.0.0.1:8081, authenticate with the login / password defined by your configuration, and you will land on nx\_extract.py interface. It is used both to generate whitelists and statistics.

You can control some parameters to control whitelist generation :
```

page_hit : Minimum number of pages triggering the same event before proposing the optimisation (ie, if there is more than 10 urls that trigger a rule, the rule will be whitelisted on every url).
Default to 10.

rules_hit : Minimum number of rules hitting the same event on the same page before proposing optimisation (ie, if there is more than 10 differents rules triggered on the same url, all rules will be whitelisted on that url)
Default to 10.
```

You can as well provide via rules\_file argument, a path to an alternative naxsi core rules file. Rules file will allow to display information about exceptions.

Here, as my website has nothing special and only very few user interaction (and because I'm lazy), I will turn page\_hit to 3.
This means, if a rules hits 3 different pages, I will turn it off for
the whole site.

```

$ wget http://127.0.0.1:8081/get_rules --http-user=naxsi_web --http-password=test
...
########### End Of Rules Before Optimisation ###########
BasicRule wl:1005 "mz:$HEADERS_VAR:cookie";
BasicRule wl:1010 "mz:$HEADERS_VAR:cookie";
BasicRule wl:1011 "mz:$HEADERS_VAR:cookie";
BasicRule wl:1308 "mz:$HEADERS_VAR:cookie";
BasicRule wl:1309 "mz:$HEADERS_VAR:cookie";
BasicRule wl:1315 "mz:$HEADERS_VAR:cookie";
```

If you look at the non-optimised part of the page, you will see :
```

#BasicRule wl:1011 "mz:$URL:/|$HEADERS_VAR:cookie";
#2 hits on rule 1308 (parenthesis) on url / from 1 different peers
...
```
This way, you know what did you decided to authorize.


I can reuse directly those rules into my /etc/nginx/memzero.rules, turn of LearningMode, and reload nginx.


## Learning Mode ? ##

The global idea behind this is that naxsi will generate whitelists from your traffic while in learning mode.
This will allow those to-be-blocked requests not to turn into false positives.

When it seems (and it generally does) possible, naxsi will factorize rules to limit learning mode length.

For example, if you have 10 generated whitelists like this :
```

BasicRule wl:1308 "mz:$URL:/page1|$HEADERS_VAR:cookie";
BasicRule wl:1308 "mz:$URL:/page2|$HEADERS_VAR:cookie";
BasicRule wl:1308 "mz:$URL:/page3|$HEADERS_VAR:cookie";
...
```

You can safely suppose that this exception will be triggered in all pages, as it's in the cookie. When something like this happens, nx\_extract will propose you the following rule instead :

```

BasicRule wl:1308 "mz:$HEADERS_VAR:cookie";
```

Which means that you will disable rule 1308 on the cookie header, for 'all' pages.


Learning of 'free' user input forms is very important as well.