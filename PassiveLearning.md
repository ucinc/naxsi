#Under construction

# Introduction #

In order to perform learning for you website, you have several possibilities. Ideally, you should do you learning "by hand", but it can be troublesome. Another option is to perform "passive" learning. Turn naxsi to learning mode, let legitimates users use your website, and, after a while, extract whitelists from exceptions generated by users.

If you do so, you are not protected during the learning phase, as naxsi will not block any requests. Another issue is that, you still have to separate false-positives from false-false-positives (attacks).

As nx\_intercept can learn both from logs or "live" trafic, you are not forced to use nx\_intercept in production. This might be a good idea if you do not need to perform advanced analysis of your requests. To do so, simply put a "return 200;" instead of a proxy\_pass in your /RequestDenied. In this way learning will be nearly processing-free as, when encountering an exception, naxsi will write just 1 line to nginx's error log.

# Initial configuration #

My server configuration (with fastcgi for php):
```

server {
...
location / {
include    /etc/nginx/blog.memze.ro.rules;
root /var/www/blog/wordpress;
index index.php;
location ~ \.php$ {
fastcgi_pass   127.0.0.1:9000;
}
}

# Disable naxsi in admin part, basic auth.
location /wp-admin {
auth_basic            "Restricted";
auth_basic_user_file  /var/www/user.pass;
root /var/www/blog/wordpress;
index index.php;
location ~ \.php$ {
fastcgi_pass   127.0.0.1:9000;
}
}

location /RequestDenied {
#proxy_pass http://127.0.0.1:8080;
return 200;
}
}
```

Don't forget to include naxsi core rules (in the http section of your nginx configuration file) :
```

include        /etc/nginx/naxsi_core.rules;
```

And naxsi's configuration :
```

LearningMode;
SecRulesEnabled;
#SecRulesDisabled;
DeniedUrl "/RequestDenied";

## check rules
CheckRule "$SQL >= 8" BLOCK;
CheckRule "$RFI >= 8" BLOCK;
CheckRule "$TRAVERSAL >= 4" BLOCK;
CheckRule "$EVADE >= 4" BLOCK;
CheckRule "$XSS >= 8" BLOCK;
```

What is expected is that naxsi will not block any requests, and will write a line to nginx's error log whenever an exception is catched.

If you want to check your setup, request a page like /foo/bar?a=<>, and you should see a line like this appear :
```

2012/06/27 22:31:30 [error] 10167#0: *44548 NAXSI_FMT: ip=x.x.x.x&server=blog.memze.ro&uri=/foo/bar&total_processed=17&total_blocked=2&zone0=ARGS&id0=1302&var_name0=a, client:x.x.x.x
```

Take a look at DeniedRequestsAndWhiteListGeneration for detailed breakdown of signatures.


If, after a few hours, you take a quick look at you erro log, you might see many of those lines. And, if you take a closer look, you might easily find a pattern repeating. Those patterns are the actual false positives.

# Extracting the whitelists #

So now that users did their part of the job (they performed the learning for you), you now have to use nx\_intercept/nx\_extract to generate whitelists from the exceptions they triggered.

nx\_intercept/nx\_extract support both sqlite3 and MySQL. MySQL is usefull if you perform learning from "live" capture, but if no real concurrent access are needed, sqlite3 is way easier.

So we will go for sqlite3. Here is nx\_extract/nx\_intercept configuration :

```

[nx_extract]
username = naxsi_web
password = test
port = 8081
rules_path = /etc/nginx/naxsi_core.rules

[nx_intercept]
port = 8080

[sqlite]
dbname = naxsi_sig
```


We can now feed nx\_intercept with nginx's error log :
python nx\_intercept.py -l /var/log/nginx/blog.memze.ro\_error.log

If your logs are big, it might be long (30s/1m) to process (Here, I inject ~60 Mo of logs).

Now that our sqlite database is fed by your logs, it's time to start nx\_extract and get those whitelists.